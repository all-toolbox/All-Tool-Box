/* eslint-disable @typescript-eslint/no-unused-vars */
import { useReducer, useState } from "react";
import * as stylex from "@stylexjs/stylex";

import { version as uuidVersion, validate as uuidValidate } from "uuid";

import * as faking from "data-faking";
import FooterHelp from "@src/tools/footer_help";
import ToolbarHelp from "@src/tools/toolbar_help";
import { help_styles } from "@src/components/footer/help/styles";
import { util_styles } from "@src/utils/styles";
import CopyTextBlock from "@src/components/commons/copy-text-block";
import Input from "@src/components/commons/input";

const styles = stylex.create({
	wrapper: {
		display: "flex",
		flexDirection: "column",
		gap: "2rem",
	},

	block: {
		display: "flex",
		flexDirection: "column",
		gap: "1rem",
	},
	validationOutput: {
		display: "flex",
		gap: "1rem",
	},
	displayWrapper: {
		display: "flex",
		flexDirection: "column",
		gap: "1rem",
	},

	button: {
		width: "fit-content",
	},
});
function UuidGenerator() {
	const [, forceUpdate] = useReducer((x) => x + 1, 0);

	const [validation, setValidation] = useState<null | {
		valid: boolean;
		version: number;
	}>(null);
	const [validationString, setValidationString] = useState<string>("");

	function UuidValidateV4(uuid: string): void {
		setValidation({
			valid: uuidValidate(uuid),
			version: uuidVersion(uuid),
		});
	}

	return (
		<div {...stylex.props(styles.wrapper)}>
			<div {...stylex.props(util_styles.display_block_base, styles.block)}>
				<h2>Outputs</h2>
				<div {...stylex.props(styles.displayWrapper)}>
					<div>
						<p>Uuid v1 Hash</p>
						<CopyTextBlock text={faking.uuid_v1()} />
					</div>
					<div>
						<p>Uuid v3 Hash</p>
						<CopyTextBlock text={faking.uuid_v3()} />
					</div>
					<div>
						<p>Uuid v4 Hash</p>
						<CopyTextBlock text={faking.uuid_v4()} />
					</div>
					<div>
						<p>Uuid v5 Hash</p>
						<CopyTextBlock text={faking.uuid_v5()} />
					</div>
					<div>
						<p>Uuid v6 Hash</p>
						<CopyTextBlock text={faking.uuid_v6()} />
					</div>
					<div>
						<p>Uuid v7 Hash</p>
						<CopyTextBlock text={faking.uuid_v7()} />
					</div>
					<div>
						<p>Uuid v8 Hash</p>
						<CopyTextBlock text={faking.uuid_v8()} />
					</div>
					<button
						onClick={forceUpdate}
						type="button"
						{...stylex.props(util_styles.button, styles.button)}
					>
						Generate New Uuids
					</button>
				</div>
			</div>
			<div
				{...stylex.props(
					util_styles.display_block_base,

					styles.block,
				)}
			>
				<h2>Validator</h2>
				<Input
					value={validationString}
					onChange={(e) => {
						setValidationString(e.target.value);
						UuidValidateV4(e.target.value);
					}}
				/>
				{/*  Only validates v1 and v4 we should expose the invoke of the rust uuid
				library */}
				{validation !== null && (
					<div {...stylex.props(styles.validationOutput)}>
						<p>v{validation.version}</p>
						<p>{validation.valid ? "Valid" : "Invalid"}</p>
					</div>
				)}
			</div>
			<FooterHelp>
				<div {...stylex.props(help_styles.base)}>
					<div {...stylex.props(help_styles.block)}>
						<h2>What is a UUID Generator?</h2>
						<p>
							This is a tool that generates uuids in the formats of v1, v3, v4,
							v5, v6, v7, and v8.
						</p>

						<h2>Rule of thumb for common cases:</h2>
						<p>
							Use `V7`` if you require a database key id that will be globally
							unique.
						</p>
						<br />
						<p>For all other cases `V4`` is a good option.</p>

						<h2>V1 and V6 (date-time and MAC address)</h2>
						<p>
							Version 1 concatenates the 48-bit MAC address of the "node" (that
							is, the computer generating the UUID), with a 60-bit timestamp,
							being the number of 100-nanosecond intervals since midnight 15
							October 1582 Coordinated Universal Time (UTC).
						</p>
						<br />
						<p>
							Version 6 is the same as version 1 except all time bits are placed
							in the opposite order. This will give systems the opportunity to
							sort in order of creation by UUID, where this wasn't possible with
							version 1.
						</p>

						<h2>V3 and V5 (namespace name-based)</h2>
						<p>
							Version 3 and version 5 UUIDs are generated by hashing a namespace
							identifier and name. Version 3 uses MD5 as the hashing algorithm,
							and version 5 uses SHA-1
						</p>
						<br />
						<p>
							To determine the version 3 UUID corresponding to a given namespace
							and name, the UUID of the namespace is transformed to a string of
							bytes, concatenated with the input name, then hashed with MD5,
							yielding 128 bits. Then 6 or 7 bits are replaced by fixed values,
							the 4-bit version (e.g. 00112 for version 3), and the 2- or 3-bit
							UUID "variant" (e.g. 102 indicating a RFC 9562 UUIDs, or 1102
							indicating a legacy Microsoft GUID). Since 6 or 7 bits are thus
							predetermined, only 121 or 122 bits contribute to the uniqueness
							of the UUID.
						</p>
						<br />
						<p>
							Version 5 UUIDs are similar, but SHA-1 is used instead of MD5.
							Since SHA-1 generates 160-bit digests, the digest is truncated to
							128 bits before the version and variant bits are replaced.
						</p>
						<br />
						<p>
							Version 3 and version 5 UUIDs have the property that the same
							namespace and name will map to the same UUID. However, neither the
							namespace nor name can be determined from the UUID, even if one of
							them is specified, except by brute-force search. RFC 4122
							recommends version 5 (SHA-1) over version 3 (MD5), and warns
							against use of UUIDs of either version as security credentials.
						</p>

						<h2>V4 (random)</h2>
						<p>
							A version 4 UUID is randomly generated. As in other UUIDs, 4 bits
							are used to indicate version 4, and 2 or 3 bits to indicate the
							variant (102 or 1102 for variants 1 and 2 respectively). Thus, for
							variant 1 (that is, most UUIDs) a random version-4 UUID will have
							6 predetermined variant and version bits, leaving 122 bits for the
							randomly generated part, for a total of 2122, or 5.3Ã—1036 (5.3
							undecillion) possible version-4 variant-1 UUIDs. There are half as
							many possible version-4 variant-2 UUIDs (legacy GUIDs) because
							there is one less random bit available, 3 bits being consumed for
							the variant.
						</p>
						<br />
						<p>
							Per RFC 9562, to communicate that a UUID is using the version 4
							format, its third group always start with the number 4. Which is
							also known as the version field. Using this format
							xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx. Where M is the UUID version
							field. For example, a random UUID version 4 end result could be
							8D8AC610-566D-4EF0-9C22-186B2A5ED793.
						</p>

						<h2>V7 (timestamp, counter and random)</h2>
						<p>
							Version 7 UUIDs (UUIDv7) are designed for keys in high-load
							databases and distributed systems.
						</p>
						<br />
						<p>
							UUIDv7 begins with a 48 bit big-endian Unix Epoch timestamp with
							approximately millisecond granularity. The timestamp can be
							shifted by any time shift value. Directly after the timestamp
							follows the version nibble, that must have a value of 7. The
							variant bits have to be 10x. Remaining 74 bits are random seeded
							counter (optional, at least 12 bits but no longer than 42 bits)
							and random.
						</p>
						<br />
						<p>Two counter rollover handling methods can be used together:</p>
						<br />
						<p>
							Zero seeded most significant, leftmost guard bit of the counter.
						</p>
						<p>
							Increment of the timestamp ahead of the actual time and
							reinitialize the counter when it overflows.
						</p>
						<p>
							In DBMS UUIDv7 generator can be shared between threads (tied to a
							table or to a DBMS instance) or can be thread-local (with worse
							monotonicity, locality and performance).
						</p>

						<h2>Version 8 (custom)</h2>
						<p>Version 8 only has two requirements:</p>
						<br />
						<p>1. The variant bits have to be 10x.</p>
						<p>2. The version nibble has to be the value of 8.</p>
						<br />
						<p>
							Those requirements tell the system that it is a version 8 UUID.
							The remaining 122 bits are up to the vendor to customize. The
							difference with version 4 is that those 122 bits are random, but
							the 122 bits in UUID version 8 are not, because they follow vendor
							specific rules.
						</p>
					</div>
				</div>
			</FooterHelp>

			<ToolbarHelp toolName="UUID Generator"></ToolbarHelp>
		</div>
	);
}

export default UuidGenerator;
